\documentclass[10pt,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}


\usepackage{listings}
\usepackage{color} %red, green, blue, yellow, cyan, magenta, black, white
\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}

\lstset{language=Matlab,% 
    %basicstyle=\color{red},
    breaklines=true,%
    morekeywords={matlab2tikz},
    keywordstyle=\color{blue},%
    morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},
    identifierstyle=\color{black},%
    stringstyle=\color{mylilas},
    commentstyle=\color{mygreen},%
    showstringspaces=false,%without this there will be a symbol in the places where there is a space
    %numbers=left,%
    %numberstyle={\tiny \color{black}},% size of the numbers
    numbersep=9pt, % this defines how far the numbers are from the text
    emph=[1]{for,end,break},emphstyle=[1]\color{red}, %some words to emphasise
    %emph=[2]{word1,word2}, emphstyle=[2]{style},    
}

\author{Ivan Rene Ramirez Castro\\
            \small \textit{Pontificia Universidad Javeriana}\\
            \small \today}
\title{\textbf{Analisis de algoritmos para el software TicoBingo}}
\date{\vspace{-5ex}}

\begin{document}

\twocolumn[
  \begin{@twocolumnfalse}
    \maketitle
    \begin{abstract}
      \begin{center}
El presente trabajo aborda de una manera didáctica el análisis de algoritmos para el software TicoBingo, el cual es un juego de bingo en el que se pueden jugar hasta 10 cartones al mismo tiempo. El software es desarrollado en el lenguaje de programación Java, utilizando hilos para la ejecución de los cartones. El análisis de algoritmos se realiza mediante el calculo de la complejidad temporal y espacial de los algoritmos utilizados en el software. Se realiza una comparación entre los algoritmos utilizados en el software y una implementación de los mismos tratando de minimizar la complejidad temporal y espacial. Se concluye que la implementación de los algoritmos en el software TicoBingo es óptima, ya que en promedios de tiempo son muy similares a los algoritmos optimizados creados para este análisis.
      \end{center}
    \end{abstract}
    KEYWORDS: \textit{Algoritmos, Complejidad temporal, Complejidad espacial, Bingo, Java, Hilo\\ \\}
  \end{@twocolumnfalse}
  ]
 
 \section{Introducción}
 
 En el mundo de la informática, el análisis de algoritmos es una de las herramientas más importantes para el desarrollo de software. El análisis de algoritmos permite conocer la complejidad temporal y espacial de los algoritmos utilizados en un software, lo cual permite conocer la eficiencia de los mismos. El análisis de algoritmos se realiza mediante el cálculo de la complejidad temporal y espacial de los algoritmos utilizados en el software. La complejidad temporal de un algoritmo se define como el número de operaciones básicas que se realizan para resolver un problema. La complejidad espacial de un algoritmo se define como el número de variables que se utilizan para resolver un problema. 
 
 Para nuestro caso, el software TicoBingo tiene algurítmos que se ejecutan en un tiempo muy corto, algoritmos de validaciones de victoria, creacion de cartones, entre otros.

 Nuestro objetivo es realizar un análisis de estos algoritmos y compararlos con una implementación de los mismos tratando de minimizar la complejidad temporal y espacial.

\subsection{TicoBingo}

El juego TicoBingo es un juego de bingo en el que se pueden jugar hasta 10 cartones al mismo tiempo. 
El software es desarrollado en el lenguaje de programación Java, utilizando hilos para la ejecución de los cartones.
El juego se inicia con la creación de los cartones, los cuales son creados de manera aleatoria teniendo en cuenta que no se repitan los números en un mismo cartón.
Cada cartón es un hilo separado que llenará su propio cartón y luego se duerme, pero cuando se genera una bolita desde el programa principal (tómbola), se despiertan todos los hilos al mismo tiempo para que busquen en su cartón si ese número está presente y lo marcará (Colorea) en el cartón de la vista. Luego de marcar la casilla con el número de la tómbola que acaba de salir, cada hilo debe revisar si ha ganado la partida, y si gana, el juego termina y el jugador de ese cartón gana, pero si no gana ningún cartón los hilos se duermen para esperar que salga otra bolita de la tómbola.


  \begin{figure}[h]
 	\centering
 	\includegraphics[width=0.5\textwidth]{ticobingointro.png}
 	\caption{Interfaz del juego TicoBingo}
 	\label{arreglo_pv}
 \end{figure}

% Seccion para explicar el tablero de bingo
\subsection{Tablero de bingo}

El tablero de bingo es una matriz de 5x5, en la cual se colocan los números aleatorios del 1 al 15, en la primera columna, los números del 16 al 30 en la segunda columna, los números del 31 al 45 en la tercera columna, los números del 46 al 60 en la cuarta columna y los números del 61 al 75 en la quinta columna. En el centro de la matriz se coloca el número 0, ya que esta casilla no se utiliza en el juego. Un numero solo puede aparecer una unica vez en la matriz.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{tablerobingointro.png}
	\caption{Tablero de bingo}
	\label{arreglo_pv}
\end{figure}

\subsection{Victoria en el juego}

Para ganar el juego, el jugador debe marcar 5 casillas en una misma fila, columna, diagonal o conseguir las 4 esquinas.

\section{Marco teórico}

En un mundo donde la tecnología avanza a pasos agigantados, es necesario que los programas que se desarrollen sean eficientes, es decir, que se ejecuten en el menor tiempo posible. Para esto, es necesario que los algoritmos que se utilicen en los programas sean eficientes, es decir, que tengan una complejidad temporal y espacial baja.

% Un algoritmo como una caja negra
\subsection{Algoritmos}

Una buena analogía para entender un algoritmo es la de una caja negra. Una caja negra es un objeto que no se puede ver por dentro, pero se sabe que tiene una entrada y una salida. La entrada es la información que se le da a la caja negra, y la salida es la información que se obtiene de la caja negra. La caja negra realiza una serie de operaciones para obtener la salida a partir de la entrada. En el caso de los algoritmos, la entrada es el problema que se quiere resolver, y la salida es la solución del problema. El algoritmo realiza una serie de operaciones para obtener la solución a partir del problema.

Pueden existir cientos de algoritmos para resolver un mismo problema, pero no todos los algoritmos son eficientes. Un algoritmo es eficiente si tiene una complejidad temporal y espacial baja. \cite{brendomatos2020algorithm}


% Complejidad temporal
\subsection{Complejidad temporal}

La complejidad temporal es el número de operaciones que realiza un algoritmo para completar su tarea (considerando que cada operación dura el mismo tiempo). El algoritmo que realiza la tarea en el menor número de operaciones se considera el más eficiente en términos de complejidad temporal. Sin embargo, la complejidad espacial y temporal se ve afectada por factores como el sistema operativo y el hardware, pero no los incluiremos en discusión. \cite{rivera2021introduccion}

Una de las notaciones más utilizadas para medir la complejidad temporal de un algoritmo es la notación Big O. La notación Big O es una notación asintótica que nos permite medir la complejidad temporal de un algoritmo. La notación Big O nos permite medir la complejidad temporal de un algoritmo en el peor de los casos.

A partir de la notación Big O, podemos evaluar si los algoritmos que se utilizan en TicoBingo son eficientes o no.

El estado del arte de la complejidad temporal de los algoritmos se utilizan benchmarks, que son pruebas que se realizan para medir el tiempo de ejecución de un algoritmo a nivel de procesador. Sin embargo, los benchmarks no son una buena forma de medir la complejidad temporal de un algoritmo, ya que dependen de la configuración del hardware, del sistema operativo y del lenguaje de programación que se utilice.

% Complejidad espacial
\subsection{Complejidad espacial}

La complejidad espacial es la cantidad de espacio en memoria que un algoritmo emplea al ejecutarse. En otras palabras, cómo el algoritmo ocupa espacio en memoria con la cantidad de elementos de entrada que debe procesar. \cite{marcelo2021arias}

La notación Big O también se utiliza para medir la complejidad espacial de un algoritmo. La notación Big O nos permite medir la complejidad espacial de un algoritmo en el peor de los casos, pero se deben tener en cuenta los siguientes aspectos:

\begin{itemize}
\item La cantidad de memoria requerida por el código del algoritmo.
\item La cantidad de memoria requerida para almacenar los datos de entrada.
\item La cantidad de memoria requerida para los datos de salida (algoritmos como los de ordenación suelen reorganizar los datos de entrada y por ello no necesitan memoria extra para la salida).
\item La cantidad de memoria requerida en cuanto a espacio de trabajo del algoritmo para realizar los cálculos y asignaciones (tanto para variables como cualquier espacio necesario en la pila para almacenar llamadas a subrutinas, este espacio es particularmente significativo para algoritmos que utilizan técnicas recursivas).
\end{itemize} \cite{steele1977debunking}



\section{Desarrollo del programa}

El programa TicoBingo se desarrolló en el lenguaje de programación Java, para este análisis se tomaron los algoritmos que se utilizaron en el programa, se transcribieron a lenguaje de python donde se realizaron las pruebas de complejidad temporal y espacial, y la comparación con algoritmos que deben ser mas eficientes.

\subsection{Algoritmos utilizados en el programa}
% resume = {
%    name: verificarGanador,
%    type: void,
%    visibility: public,
%    parameters: [],
%    description: Valida si el tablero actual es ganador, si lo es, se agrega a la lista de ganadores del estado
% }
\begin{itemize}
\item \textbf{verificarGanador}: Valida si el tablero actual es ganador, si lo es, se agrega a la lista de ganadores del estado.
% resume = {
% name: estaRepetido,
% type: boolean,
% visibility: private,
% parameters: [numero],
% description: Verifica si un numero esta repetido en el tablero
% }
\item \textbf{estaRepetido}: Verifica si un numero esta repetido en el tablero.
% resume = {
% name: generarNumeroAleatorio,
% type: int,
% visibility: private,
% parameters: [minimo, maximo],
% description: Genera un numero aleatorio entre minimo y maximo
% }
\item \textbf{generarNumeroAleatorio}: Genera un numero aleatorio entre minimo y maximo.
% resume = {
% name: generarTableroAleatorio,
% type: void,
% visibility: private,
% parameters: [],
% description: Genera un tablero aleatorio
% }
\item \textbf{generarTableroAleatorio}: Genera un tablero aleatorio.

\end{itemize}


\subsection{Análisis de complejidad}

\subsubsection{verificarGanador}

El algoritmo verificarGanador se encarga de verificar si el tablero actual es ganador, si lo es, se agrega a la lista de ganadores del estado. El algoritmo verificarGanador se muestra a continuación:
Ver Codigo \ref{verificarGanador}

\subsubsection{estaRepetido}

El algoritmo estaRepetido se encarga de verificar si un numero esta repetido en el tablero. El algoritmo estaRepetido se muestra a continuación:
Ver Codigo \ref{estaRepetido}

\subsubsection{generarNumeroAleatorio}

El algoritmo generarNumeroAleatorio se encarga de generar un numero aleatorio entre minimo y maximo. El algoritmo generarNumeroAleatorio se muestra a continuación:
Ver Codigo \ref{generarNumeroAleatorio}

\subsubsection{generarTableroAleatorio}

El algoritmo generarTableroAleatorio se encarga de generar un tablero aleatorio. El algoritmo generarTableroAleatorio se muestra a continuación:
Ver Codigo \ref{generarTableroAleatorio}


\section{Conclusiones}

% # Compejidad espacial de los datos de entrada

% # Los datos de entrada son un diccionario con 5 claves, donde 3 son enteros, 1 es una lista de listas y 1 es una lista
% # Por lo tanto el espacio de los datos de entrada es O(5) = O(1)

% # Compejidad espacial de los datos de salida

% # Los datos de salida son un diccionario con 6 claves, donde 3 son enteros, 1 es una lista de listas, 1 es una lista y 1 es None o una lista
% # Por lo tanto el espacio de los datos de salida es O(6) = O(1)

% # Analisis

% # Podemos concluir que la complejidad temporal de la funcion verificarGanador no es O(n) ya que no se recorre ninguna lista con un n desconocido
% # Por lo tanto la complejidad temporal de la funcion verificarGanador es O(1)

% # Podemos concluir que la complejidad espacial de la funcion verificarGanador no es O(n) ya que no se crean espacio de memoria para listas con un n desconocido
% # Por lo tanto la complejidad espacial de la funcion verificarGanador es O(1)

% # Podemos concluir que la complejidad temporal de la funcion verificarGanador es O(1) y la complejidad espacial de la funcion verificarGanador es O(1) y es un algoritmo eficiente en tiempo y espacio


\subsection{Funcion verificarGanador}

Ahora analizaremos la funcion verificarGanador, a continuacion se muestra una tabla con el analisis de complejidad temporal y espacial de la funcion verificarGanador:
Ver Tabla \ref{tablaComplejidadVerificarGanador}

\subsection{Datos de entrada}
\begin{itemize}
\item Un diccionario con 5 claves, donde 3 son enteros, 1 es una lista de listas y 1 es una lista
\end{itemize}

\subsection{Datos de salida}
\begin{itemize}
\item Un diccionario con 6 claves, donde 3 son enteros, 1 es una lista de listas, 1 es una lista y 1 es None o una lista
\end{itemize}

\subsection{Analisis}
\begin{itemize}
\item Podemos concluir que la complejidad temporal de la funcion verificarGanador no es O(n) ya que no se recorre ninguna lista con un n desconocido
\item Por lo tanto la complejidad temporal de la funcion verificarGanador es O(1)
\end{itemize}


% # Compejidad espacial de los datos de entrada

% # Los datos de entrada son un entero
% # Por lo tanto el espacio de los datos de entrada es O(1)

% # Compejidad espacial de los datos de salida

% # Los datos de salida son un booleano
% # Por lo tanto el espacio de los datos de salida es O(1)

% # Analisis

% # Podemos concluir que la complejidad temporal de la funcion estaRepetido es O(1), al ser compuesta por 5 operaciones estaticas

% # Podemos concluir que la complejidad espacial de la funcion estaRepetido es O(1), por no crear espacio de memoria variables

\subsection{Funcion estaRepetido}

Ahora analizaremos la funcion estaRepetido, a continuacion se muestra una tabla con el analisis de complejidad temporal y espacial de la funcion estaRepetido:
Ver Tabla \ref{tablaComplejidadEstaRepetido}

\subsection{Datos de entrada}
\begin{itemize}
\item Un entero
\end{itemize}

\subsection{Datos de salida}
\begin{itemize}
\item Un booleano
\end{itemize}

\subsection{Analisis}
\begin{itemize}
\item Podemos concluir que la complejidad temporal de la funcion estaRepetido es O(1), al ser compuesta por 5 operaciones estaticas
\item Podemos concluir que la complejidad espacial de la funcion estaRepetido es O(1), por no crear espacio de memoria variables
\end{itemize}

% # Compejidad espacial de los datos de entrada

% # Los datos de entrada son dos enteros
% # Por lo tanto el espacio de los datos de entrada es O(2) = O(1)

% # Compejidad espacial de los datos de salida

% # Los datos de salida son un entero
% # Por lo tanto el espacio de los datos de salida es O(1)

% # Analisis

% # Podemos concluir que la complejidad temporal de la funcion generarNumeroAleatorio es O(1), al ser compuesta por 1 operacion estatica

% # Podemos concluir que la complejidad espacial de la funcion generarNumeroAleatorio es O(1), por no crear espacio de memoria variables


\subsection{Funcion generarNumeroAleatorio}

Ahora analizaremos la funcion generarNumeroAleatorio, a continuacion se muestra una tabla con el analisis de complejidad temporal y espacial de la funcion generarNumeroAleatorio:
Ver Tabla \ref{tablaComplejidadGenerarNumeroAleatorio}

\subsection{Datos de entrada}
\begin{itemize}
\item Dos enteros
\end{itemize}

\subsection{Datos de salida}
\begin{itemize}
\item Un entero
\end{itemize}

\subsection{Analisis}
\begin{itemize}
\item Podemos concluir que la complejidad temporal de la funcion generarNumeroAleatorio es O(1), al ser compuesta por 1 operacion estatica
\item Podemos concluir que la complejidad espacial de la funcion generarNumeroAleatorio es O(1), por no crear espacio de memoria variables
\end{itemize}


% # Compejidad espacial de los datos de entrada

% # Los datos de entrada son una matriz de 5x5
% # Por lo tanto el espacio de los datos de entrada es O(25) = O(1)

% # Compejidad espacial de los datos de salida
% # Los datos de salida son una matriz de 5x5
% # Por lo tanto el espacio de los datos de salida es O(25) = O(1)

% # Analisis

% # Podemos concluir que la complejidad temporal de la funcion generarTableroAleatorio es O(80 + ? + ?) = O(?), ya que no tenemos certeza de la complejidad de las funciones estaRepetido y generarNumeroAleatorio ya que es una funcion que nosotros no podemos controlar, en el peor de los casos la complejidad de la funcion estaRepetido es O(n) y la complejidad de la funcion generarNumeroAleatorio es O(1), por lo tanto la complejidad temporal de la funcion generarTableroAleatorio es O(80 + n + 1) = O(n)

% # La complejidad espacial de la funcion generarTableroAleatorio es O(47) = O(1), ya que la complejidad espacial de los datos de entrada es O(1) y la complejidad espacial de los datos de salida es O(1)


\subsection{Funcion generarTableroAleatorio}

Ahora analizaremos la funcion generarTableroAleatorio, a continuacion se muestra una tabla con el analisis de complejidad temporal y espacial de la funcion generarTableroAleatorio:
Ver Tabla \ref{tablaComplejidadGenerarTableroAleatorio}

\subsection{Datos de entrada}
\begin{itemize}
\item Una matriz de 5x5
\end{itemize}

\subsection{Datos de salida}
\begin{itemize}
\item Una matriz de 5x5
\end{itemize}

\subsection{Analisis}
\begin{itemize}
\item Podemos concluir que la complejidad temporal de la funcion generarTableroAleatorio es O(80 + ? + ?) = O(?), ya que no tenemos certeza de la complejidad de las funciones estaRepetido y generarNumeroAleatorio ya que es una funcion que nosotros no podemos controlar, en el peor de los casos la complejidad de la funcion estaRepetido es O(n) y la complejidad de la funcion generarNumeroAleatorio es O(1), por lo tanto la complejidad temporal de la funcion generarTableroAleatorio es O(80 + n + 1) = O(n)
\item La complejidad espacial de la funcion generarTableroAleatorio es O(47) = O(1), ya que la complejidad espacial de los datos de entrada es O(1) y la complejidad espacial de los datos de salida es O(1)
\end{itemize}











\newpage

\bibliographystyle{ieeetr}
\bibliography{mybib}




% Pagina de una sola columna
\onecolumn

% Anexos
\section{Anexos}

\subsection{Anexo 1: Codigo fuente verificarGanador()}

% habilitar los numeros de linea
\begin{lstlisting}[language=python, caption={Algoritmo verificarGanador}, label={verificarGanador}, captionpos=b, basicstyle=\footnotesize\ttfamily, numbers=left, numberstyle=\tiny, numbersep=5pt, stepnumber=1, numberblanklines=true, frame=single, framesep=2mm, rulesepcolor=\color{black}]

# Transcripción del código de Java a Python
def verificarGanador(datos: any):
	"""
	Valida si el tablero actual es ganador, si lo es, se agrega a la lista de ganadores del estado
	"""
	# Un jugador puede ganar llenando cualquier fila, columna, diagonales o cuatro esquinas solamente, los numeros que se encuentran en el centro no cuentan
	# los numeros que han salido estan en la lista de numeros
	# id: complejidad temporal, complejidad espacial(si aplica) osea si se esta usando memoria extra
	ganador = False # 1: O(1), O(1)
	# verificar filas
	for i in range(5): # 2: O(5), O(1)
		numerosEncontradosFila = [False] * 5 # 3: O(5), O(5)
		for j in range(5): # 4: O(5), O(1)
			for k in range(datos["indexNumeros"]): # 5: O(5), O(1)
				if datos["tablero"][i][j] == datos["numeros"][k]: # 6: O(1), O(0)
					numerosEncontradosFila[j] = True # 7: O(1), O(1)
		if numerosEncontradosFila[0] and numerosEncontradosFila[1] and numerosEncontradosFila[2] and numerosEncontradosFila[3] and numerosEncontradosFila[4]: # 8: O(1), O(0)
			ganador = True # 9: O(1), O(1)
			break # 10: O(1), O(0)
	# verificar columnas
	if not ganador: # 11: O(1), O(0)
		for i in range(5):  # 12: O(5), O(1)
			numerosEncontradosColumna = [False] * 5 # 13: O(5), O(5)
			for j in range(5): # 14: O(5), O(1)
				for k in range(datos["indexNumeros"]): # 15: O(5), O(1)
					if datos["tablero"][j][i] == datos["numeros"][k]: # 16: O(1), O(0)
						numerosEncontradosColumna[j] = True # 17: O(1), O(1)
			if numerosEncontradosColumna[0] and numerosEncontradosColumna[1] and numerosEncontradosColumna[2] and numerosEncontradosColumna[3] and numerosEncontradosColumna[4]: # 18: O(1), O(0)
				ganador = True # 19: O(1), O(1)
				break # 20: O(1), O(0)
	# verificar diagonales
	if not ganador: # 21: O(1), O(0)
		numerosEncontradosDiagonal1 = [False] * 5 # 22: O(5), O(5)
		numerosEncontradosDiagonal2 = [False] * 5 # 23: O(5), O(5)
		for i in range(5): # 24: O(5), O(1)
			for k in range(datos["indexNumeros"]): # 25: O(5), O(1)
				if datos["tablero"][i][i] == datos["numeros"][k]: # 26: O(1), O(0)
					numerosEncontradosDiagonal1[i] = True # 27: O(1), O(1)
				if datos["tablero"][i][4 - i] == datos["numeros"][k]: # 28: O(1), O(0)
					numerosEncontradosDiagonal2[i] = True # 29: O(1), O(1)
		if numerosEncontradosDiagonal1[0] and numerosEncontradosDiagonal1[1] and numerosEncontradosDiagonal1[2] and numerosEncontradosDiagonal1[3] and numerosEncontradosDiagonal1[4]: # 30: O(1), O(0)
			ganador = True # 31: O(1), O(1)
		if numerosEncontradosDiagonal2[0] and numerosEncontradosDiagonal2[1] and numerosEncontradosDiagonal2[2] and numerosEncontradosDiagonal2[3] and numerosEncontradosDiagonal2[4]: # 32: O(1), O(0)
			ganador = True # 33: O(1), O(1)
	# verificar esquinas
	if not ganador: # 34: O(1), O(0)
		numerosEncontradosEsquinas = [False] * 4 # 35: O(4), O(4)
		for i in range(4): # 36: O(4), O(1)
			for k in range(datos["indexNumeros"]): # 37: O(5), O(1)
				if datos["tablero"][0][0] == datos["numeros"][k]: # 38: O(1), O(0)
					numerosEncontradosEsquinas[0] = True # 39: O(1), O(1)
				if datos["tablero"][0][4] == datos["numeros"][k]: # 40: O(1), O(0)
					numerosEncontradosEsquinas[1] = True # 41: O(1), O(1)
				if datos["tablero"][4][0] == datos["numeros"][k]: # 42: O(1), O(0)
					numerosEncontradosEsquinas[2] = True # 43: O(1), O(1)
				if datos["tablero"][4][4] == datos["numeros"][k]: # 44: O(1), O(0)
					numerosEncontradosEsquinas[3] = True # 45: O(1), O(1)
		if numerosEncontradosEsquinas[0] and numerosEncontradosEsquinas[1] and numerosEncontradosEsquinas[2] and numerosEncontradosEsquinas[3]: # 46: O(1), O(0)
			ganador = True # 47: O(1), O(1)
	if ganador: # 48: O(1), O(0)
		if datos["ganadores"] != None: # 49: O(1), O(0)
			# Agregar a la lista de ganadores
			ganadores = datos["ganadores"] # 50: O(1), O(1)
			# verificar que este tablero no este en la lista de ganadores
			if not datos["id"] in ganadores: # 51: O(1), O(0)
				ganadores.append(datos["id"]) # 52: O(1), O(1)
			datos["ganadores"] = ganadores # 53: O(1), O(1)
		else: # 54: O(1), O(0)
			# Crear la lista de ganadores
			ganadores = [] # 55: O(1), O(1)
			ganadores.append(datos["id"]) # 56: O(1), O(1)
			datos["ganadores"] = ganadores # 57: O(1), O(1)

# Test
datos = { 
	"id": 1,
	"tablero": [
		[4, 16, 43, 54, 65],
		[8, 17, 44, 55, 66],
		[9, 18, 45, 56, 67],
		[10, 19, 46, 57, 68],
		[11, 20, 47, 58, 69]
	],
	"numeros": [4, 16, 43, 54, 65, 8, 17, 44, 55, 66, 9, 18, 45, 56, 67, 10, 19, 46, 57, 68, 11, 20, 47, 58, 69],
	"indexNumeros": 25,
	"ganadores": None
}
# en milisegundos
verificarGanador(datos)
print(datos)
\end{lstlisting}

% # Metodo privado para verificar si un numero esta repetido en el tablero
% def estaRepetido(numero: int) -> bool:
%     # Recorre el arreglo de numeros
%     for i in range(5): # 1: O(5), O(1)
%         # Recorre el arreglo de numeros
%         for j in range(5): # 2: O(5), O(1)
%             # Verifica si el numero esta repetido
%             if tablero[i][j] == numero: # 3: O(1), O(0)
%                 return True # 4: O(1), O(1)
%     return False # 5: O(1), O(1)


\subsection{Anexo 2: Codigo fuente estaRepetido()}

\begin{lstlisting}[language=python, caption={Algoritmo estaRepetido}, label={estaRepetido}, captionpos=b, basicstyle=\footnotesize\ttfamily, numbers=left, numberstyle=\tiny, numbersep=5pt, stepnumber=1, numberblanklines=true, frame=single, framesep=2mm, rulesepcolor=\color{black}]
# Metodo privado para verificar si un numero esta repetido en el tablero
def estaRepetido(numero: int) -> bool:
	# Recorre el arreglo de numeros
	for i in range(5): # 1: O(5), O(1)
		# Recorre el arreglo de numeros
		for j in range(5): # 2: O(5), O(1)
			# Verifica si el numero esta repetido
			if tablero[i][j] == numero: # 3: O(1), O(0)
				return True # 4: O(1), O(1)
	return False # 5: O(1), O(1)
\end{lstlisting}


% import random
% # Metodo privado para generar un numero aleatorio
% def generarNumeroAleatorio(minimo: int, maximo: int) -> int:
%     return random.randint(minimo, maximo) # 1: O(1), O(1)

\subsection{Anexo 3: Codigo fuente generarNumeroAleatorio()}
\begin{lstlisting}[language=python, caption={Algoritmo generarNumeroAleatorio}, label={generarNumeroAleatorio}, captionpos=b, basicstyle=\footnotesize\ttfamily, numbers=left, numberstyle=\tiny, numbersep=5pt, stepnumber=1, numberblanklines=true, frame=single, framesep=2mm, rulesepcolor=\color{black}]
import random
# Metodo privado para generar un numero aleatorio
def generarNumeroAleatorio(minimo: int, maximo: int) -> int:
	return random.randint(minimo, maximo) # 1: O(1), O(1)
\end{lstlisting}


% # Metodo privado para generar un tablero
% def generarTableroAleatorio(data: any):
%     numero: int # 1: O(1), O(1)
%     columna: int # 2: O(1), O(1)
%     fila: int # 3: O(1), O(1)
%     numeros: list[int] = [0] * 25 # 4: O(25), O(25)
%     # Genera los numeros aleatorios 
%     for i in range(25): # 5: O(25), O(1)
%         # Genera un numero aleatorio
%         numero = generarNumeroAleatorio(1, 75) # 6: O(funcion), O(1)
%         # Verifica que el numero no este repetido
%         while estaRepetido(numero): # 7: O(?), O(0)
%             numero = generarNumeroAleatorio(1, 75) # 8: O(funcion), O(1)
%         # Agrega el numero al arreglo
%         numeros[i] = numero # 9: O(1), O(1)
%     # Asigna los numeros al tablero
%     for i in range(25): # 10: O(25), O(1)
%         # Obtiene el numero
%         numero = numeros[i] # 11: O(1), O(1)
%         # Obtiene la columna
%         columna = i % 5 # 12: O(1), O(1)
%         # Obtiene la fila
%         fila = i // 5 # 13: O(1), O(1)
%         # Asigna el numero al tablero
%         data[fila][columna] = numero # 14: O(1), O(1)
%     # Asigna los numeros a las columnas
%     for i in range(5): # 15: O(5), O(1)
%         # Obtiene la columna
%         columna = i # 16: O(1), O(1)
%         # Obtiene el numero minimo
%         minimo = (columna * 15) + 1 # 17: O(1), O(1)
%         # Obtiene el numero maximo
%         maximo = minimo + 14 # 18: O(1), O(1)
%         # Asigna los numeros a la columna
%         for j in range(5): # 19: O(5), O(1)
%             # Obtiene el numero
%             numero = data[j][columna] # 20: O(1), O(1)
%             # Verifica que el numero este en el rango
%             if numero < minimo or numero > maximo: # 21: O(1), O(0)
%                 # Genera un numero aleatorio
%                 numero = generarNumeroAleatorio(minimo, maximo) # 22: O(funcion), O(1)
%                 # Verifica que el numero no este repetido
%                 while estaRepetido(numero): # 23: O(?), O(0)
%                     numero = generarNumeroAleatorio(minimo, maximo) # 24: O(funcion), O(1)
%                 # Asigna el numero al tablero
%                 data[j][columna] = numero # 25: O(1), O(1)
%     # Asigna el numero 0 a la casilla central
%     data[2][2] = 0 # 26: O(1), O(1)
%     # this.imprimirTablero();
%     # refreshPanel()

\subsection{Anexo 4: Codigo fuente generarTableroAleatorio()}
\begin{lstlisting}[language=python, caption={Algoritmo generarTableroAleatorio}, label={generarTableroAleatorio}, captionpos=b, basicstyle=\footnotesize\ttfamily, numbers=left, numberstyle=\tiny, numbersep=5pt, stepnumber=1, numberblanklines=true, frame=single, framesep=2mm, rulesepcolor=\color{black}]
# Metodo privado para generar un tablero
def generarTableroAleatorio(data: any):
	numero: int # 1: O(1), O(1)
	columna: int # 2: O(1), O(1)
	fila: int # 3: O(1), O(1)
	numeros: list[int] = [0] * 25 # 4: O(25), O(25)
	# Genera los numeros aleatorios 
	for i in range(25): # 5: O(25), O(1)
		# Genera un numero aleatorio
		numero = generarNumeroAleatorio(1, 75) # 6: O(funcion), O(1)
		# Verifica que el numero no este repetido
		while estaRepetido(numero): # 7: O(?), O(0)
			numero = generarNumeroAleatorio(1, 75) # 8: O(funcion), O(1)
		# Agrega el numero al arreglo
		numeros[i] = numero # 9: O(1), O(1)
	# Asigna los numeros al tablero
	for i in range(25): # 10: O(25), O(1)
		# Obtiene el numero
		numero = numeros[i] # 11: O(1), O(1)
		# Obtiene la columna
		columna = i % 5 # 12: O(1), O(1)
		# Obtiene la fila
		fila = i // 5 # 13: O(1), O(1)
		# Asigna el numero al tablero
		data[fila][columna] = numero # 14: O(1), O(1)
	# Asigna los numeros a las columnas
	for i in range(5): # 15: O(5), O(1)
		# Obtiene la columna
		columna = i # 16: O(1), O(1)
		# Obtiene el numero minimo
		minimo = (columna * 15) + 1 # 17: O(1), O(1)
		# Obtiene el numero maximo
		maximo = minimo + 14 # 18: O(1), O(1)
		# Asigna los numeros a la columna
		for j in range(5): # 19: O(5), O(1)
			# Obtiene el numero
			numero = data[j][columna] # 20: O(1), O(1)
			# Verifica que el numero este en el rango
			if numero < minimo or numero > maximo: # 21: O(1), O(0)
				# Genera un numero aleatorio
				numero = generarNumeroAleatorio(minimo, maximo) # 22: O(funcion), O(1)
				# Verifica que el numero no este repetido
				while estaRepetido(numero): # 23: O(?), O(0)
					numero = generarNumeroAleatorio(minimo, maximo) # 24: O(funcion), O(1)
				# Asigna el numero al tablero
				data[j][columna] = numero # 25: O(1), O(1)
	# Asigna el numero 0 a la casilla central
	data[2][2] = 0 # 26: O(1), O(1)
	# this.imprimirTablero();
	# refreshPanel()
\end{lstlisting}

% # Analisis de complejidad temporal y espacial de la funcion verificarGanador
% \subsection{Anexo 5: Tabla con los resultados de análisis de complejidad de el algoritmo de verificación de ganador}
% # |---------------| Temporal                | Espacial                   |
% # |---------------|-------------------------|----------------------------|
% # | Identificador | Operacion | Complejidad | Tipo de dato | Espacio     |
% # |---------------|-----------|-------------|--------------|-------------|
% # | 1             | =         | 1           | bool         | 1           |
% # | 2             | for       | 5           | int          | 1           |
% # | 3             | =         | 5           | bool         | 5           |
% # | 4             | for       | 5           | int          | 1           |
% # | 5             | for       | 5           | int          | 1           |
% # | 6             | ==        | 1           | bool         | 1           |
% # | 7             | =         | 1           | bool         | 1           |
% # | 8             | and       | 1           | bool         | 1           |
% # | 9             | =         | 1           | bool         | 1           |
% # | 10            | break     | 1           | None         | 0           |
% # | 11            | not       | 1           | bool         | 1           |
% # | 12            | for       | 5           | int          | 1           |
% # | 13            | =         | 5           | bool         | 5           |
% # | 14            | for       | 5           | int          | 1           |
% # | 15            | for       | 5           | int          | 1           |
% # | 16            | ==        | 1           | bool         | 1           |
% # | 17            | =         | 1           | bool         | 1           |
% # | 18            | and       | 1           | bool         | 1           |
% # | 19            | =         | 1           | bool         | 1           |
% # | 20            | break     | 1           | None         | 0           |
% # | 21            | not       | 1           | bool         | 1           |
% # | 22            | =         | 5           | bool         | 5           |
% # | 23            | =         | 5           | bool         | 5           |
% # | 24            | for       | 5           | int          | 1           |
% # | 25            | for       | 5           | int          | 1           |
% # | 26            | ==        | 1           | bool         | 1           |
% # | 27            | =         | 1           | bool         | 1           |
% # | 28            | ==        | 1           | bool         | 1           |
% # | 29            | =         | 1           | bool         | 1           |
% # | 30            | and       | 1           | bool         | 1           |
% # | 31            | =         | 1           | bool         | 1           |
% # | 32            | and       | 1           | bool         | 1           |
% # | 33            | =         | 1           | bool         | 1           |
% # | 34            | not       | 1           | bool         | 1           |
% # | 35            | =         | 4           | bool         | 4           |
% # | 36            | for       | 4           | int          | 1           |
% # | 37            | for       | 5           | int          | 1           |
% # | 38            | ==        | 1           | bool         | 1           |
% # | 39            | =         | 1           | bool         | 1           |
% # | 40            | ==        | 1           | bool         | 1           |
% # | 41            | =         | 1           | bool         | 1           |
% # | 42            | ==        | 1           | bool         | 1           |
% # | 43            | =         | 1           | bool         | 1           |
% # | 44            | ==        | 1           | bool         | 1           |
% # | 45            | =         | 1           | bool         | 1           |
% # | 46            | and       | 1           | bool         | 1           |
% # | 47            | =         | 1           | bool         | 1           |
% # | 48            | if        | 1           | None         | 0           |
% # | 49            | !=        | 1           | bool         | 1           |
% # | 50            | =         | 1           | list         | 1           |
% # | 51            | not       | 1           | bool         | 1           |
% # | 52            | append    | 1           | None         | 0           |
% # | 53            | =         | 1           | list         | 1           |
% # | 54            | else      | 1           | None         | 0           |
% # | 55            | =         | 1           | list         | 1           |
% # | 56            | append    | 1           | None         | 0           |
% # | 57            | =         | 1           | list         | 1           |
% # |---------------|-----------|-------------|--------------|-------------|
% # | Total         |           | 115         |              | 70          |
% # |---------------|-----------|-------------|--------------|-------------|

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Linea} & \textbf{Operacion} & \textbf{Valor} & \textbf{Tipo} & \textbf{Espacio} \\
\hline
1 & = & 1 & bool & 1 \\
2 & for & 5 & int & 1 \\
3 & = & 5 & bool & 5 \\
4 & for & 5 & int & 1 \\
5 & for & 5 & int & 1 \\
6 & == & 1 & bool & 1 \\
7 & = & 1 & bool & 1 \\
8 & and & 1 & bool & 1 \\
9 & = & 1 & bool & 1 \\
10 & break & 1 & None & 0 \\
11 & not & 1 & bool & 1 \\
12 & for & 5 & int & 1 \\
13 & = & 5 & bool & 5 \\
14 & for & 5 & int & 1 \\
15 & for & 5 & int & 1 \\
16 & == & 1 & bool & 1 \\
17 & = & 1 & bool & 1 \\
18 & and & 1 & bool & 1 \\
19 & = & 1 & bool & 1 \\
20 & break & 1 & None & 0 \\
21 & not & 1 & bool & 1 \\
22 & = & 5 & bool & 5 \\
23 & = & 5 & bool & 5 \\
24 & for & 5 & int & 1 \\
25 & for & 5 & int & 1 \\
26 & == & 1 & bool & 1 \\
27 & = & 1 & bool & 1 \\
28 & == & 1 & bool & 1 \\
29 & = & 1 & bool & 1 \\
30 & and & 1 & bool & 1 \\
31 & = & 1 & bool & 1 \\
32 & and & 1 & bool & 1 \\
33 & = & 1 & bool & 1 \\
34 & not & 1 & bool & 1 \\
35 & = & 4 & bool & 4 \\
36 & for & 4 & int & 1 \\
37 & for & 5 & int & 1 \\
38 & == & 1 & bool & 1 \\
39 & = & 1 & bool & 1 \\
40 & == & 1 & bool & 1 \\
41 & = & 1 & bool & 1 \\
42 & == & 1 & bool & 1 \\
43 & = & 1 & bool & 1 \\
44 & == & 1 & bool & 1 \\
45 & = & 1 & bool & 1 \\
46 & and & 1 & bool & 1 \\
47 & = & 1 & bool & 1 \\
48 & if & 1 & None & 0 \\
49 & != & 1 & bool & 1 \\
50 & = & 1 & list & 1 \\
51 & not & 1 & bool & 1 \\
52 & append & 1 & None & 0 \\
53 & = & 1 & list & 1 \\
54 & else & 1 & None & 0 \\
55 & = & 1 & list & 1 \\
56 & append & 1 & None & 0 \\
57 & = & 1 & list & 1 \\

\hline
\textbf{Total} &  & 115 &  & 70 \\
\hline
\end{tabular}
\caption{Complejidad temporal de la funcion verificarGanador}
\label{tablaComplejidadVerificarGanador}
\end{table}




% # Analisis de complejidad temporal y espacial de la funcion estaRepetido
% \subsection{Anexo 6: Tabla con los resultados de análisis de complejidad temporal y espacial de la función estaRepetido}
% # |---------------| Temporal                | Espacial                   |
% # |---------------|-------------------------|----------------------------|
% # | Identificador | Operacion | Complejidad | Tipo de dato | Espacio     |
% # |---------------|-----------|-------------|--------------|-------------|
% # | 1             | for       | 5           | int          | 1           |
% # | 2             | for       | 5           | int          | 1           |
% # | 3             | ==        | 1           | bool         | 1           |
% # | 4             | =         | 1           | bool         | 1           |
% # | 5             | =         | 1           | bool         | 1           |
% # |---------------|-----------|-------------|--------------|-------------|
% # | Total         |           | 13          |              | 5           |
% # |---------------|-----------|-------------|--------------|-------------|

\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Linea} & \textbf{Operacion} & \textbf{Valor} & \textbf{Tipo} & \textbf{Espacio} \\
\hline
1 & for & 5 & int & 1 \\
2 & for & 5 & int & 1 \\
3 & == & 1 & bool & 1 \\
4 & = & 1 & bool & 1 \\
5 & = & 1 & bool & 1 \\
\hline
\textbf{Total} &  & 13 &  & 5 \\
\hline
\end{tabular}
\caption{Complejidad temporal de la funcion estaRepetido}
\label{tablaComplejidadEstaRepetido}
\end{table}




% # Analisis de complejidad temporal y espacial de la funcion generarNumeroAleatorio
% \subsection{Anexo 7: Tabla con los resultados de análisis de complejidad temporal y espacial de la función generarNumeroAleatorio}
% # |---------------| Temporal                | Espacial                   |
% # |---------------|-------------------------|----------------------------|
% # | Identificador | Operacion | Complejidad | Tipo de dato | Espacio     |
% # |---------------|-----------|-------------|--------------|-------------|
% # | 1             | =         | 1           | int          | 1           |
% # |---------------|-----------|-------------|--------------|-------------|
% # | Total         |           | 1           |              | 1           |
% # |---------------|-----------|-------------|--------------|-------------|


\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Linea} & \textbf{Operacion} & \textbf{Valor} & \textbf{Tipo} & \textbf{Espacio} \\
\hline
1 & = & 1 & int & 1 \\
\hline
\textbf{Total} &  & 1 &  & 1 \\
\hline
\end{tabular}
\caption{Complejidad temporal de la funcion generarNumeroAleatorio}
\label{tablaComplejidadGenerarNumeroAleatorio}
\end{table}



% # Analisis de complejidad temporal y espacial de la funcion generarTableroAleatorio
% \subsection{Anexo 8: Tabla con los resultados de análisis de complejidad temporal y espacial de la función generarTableroAleatorio}
% # |---------------| Temporal                | Espacial                   |
% # |---------------|-------------------------|----------------------------|
% # | Identificador | Operacion | Complejidad | Tipo de dato | Espacio     |
% # |---------------|-----------|-------------|--------------|-------------|
% # | 1             | =         | 1           | int          | 1           |
% # | 2             | =         | 1           | int          | 1           |
% # | 3             | =         | 1           | int          | 1           |
% # | 4             | =         | 1           | list[int]    | 25          |
% # | 5             | for       | 25          |              | 1           |
% # | 6             | =         | 1           | int          | 1           |
% # | 7             | while     | ?           |              | 0           |
% # | 8             | =         | 1           | int          | 1           |
% # | 9             | =         | 1           | int          | 1           |
% # | 10            | for       | 25          |              | 1           |
% # | 11            | =         | 1           | int          | 1           |
% # | 12            | =         | 1           | int          | 1           |
% # | 13            | =         | 1           | int          | 1           |
% # | 14            | =         | 1           | int          | 1           |
% # | 15            | for       | 5           |              | 1           |
% # | 16            | =         | 1           | int          | 1           |
% # | 17            | =         | 1           | int          | 1           |
% # | 18            | =         | 1           | int          | 1           |
% # | 19            | for       | 5           |              | 1           |
% # | 20            | =         | 1           | int          | 1           |
% # | 21            | if        | 1           |              | 0           |
% # | 22            | =         | 1           | int          | 1           |
% # | 23            | while     | ?           |              | 0           |
% # | 24            | =         | 1           | int          | 1           |
% # | 25            | =         | 1           | int          | 1           |
% # | 26            | =         | 1           | int          | 1           |
% # |---------------|-----------|-------------|--------------|-------------|
% # | Total         |           | 80 + ? + ?  |              | 47          |
% # |---------------|-----------|-------------|--------------|-------------|


\begin{table}[h]
\centering
\begin{tabular}{|c|c|c|c|c|}
\hline
\textbf{Linea} & \textbf{Operacion} & \textbf{Valor} & \textbf{Tipo} & \textbf{Espacio} \\
\hline
1 & = & 1 & int & 1 \\
2 & = & 1 & int & 1 \\
3 & = & 1 & int & 1 \\
4 & = & 1 & list[int] & 25 \\
5 & for & 25 &  & 1 \\
6 & = & 1 & int & 1 \\
7 & while & ? &  & 0 \\
8 & = & 1 & int & 1 \\
9 & = & 1 & int & 1 \\
10 & for & 25 &  & 1 \\
11 & = & 1 & int & 1 \\
12 & = & 1 & int & 1 \\
13 & = & 1 & int & 1 \\
14 & = & 1 & int & 1 \\
15 & for & 5 &  & 1 \\
16 & = & 1 & int & 1 \\
17 & = & 1 & int & 1 \\
18 & = & 1 & int & 1 \\
19 & for & 5 &  & 1 \\
20 & = & 1 & int & 1 \\
21 & if & 1 &  & 0 \\
22 & = & 1 & int & 1 \\
23 & while & ? &  & 0 \\
24 & = & 1 & int & 1 \\
25 & = & 1 & int & 1 \\
26 & = & 1 & int & 1 \\
\hline
\textbf{Total} &  & 80 + ? + ? &  & 47 \\
\hline
\end{tabular}
\caption{Complejidad temporal de la funcion generarTableroAleatorio}
\label{tablaComplejidadGenerarTableroAleatorio}
\end{table}



\end{document}


