\documentclass[10pt,twocolumn]{article}
\usepackage[utf8]{inputenc}
\usepackage[spanish]{babel}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{graphicx}
\usepackage[left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}


\usepackage{listings}
\usepackage{color} %red, green, blue, yellow, cyan, magenta, black, white
\definecolor{mygreen}{RGB}{28,172,0} % color values Red, Green, Blue
\definecolor{mylilas}{RGB}{170,55,241}

\lstset{language=Matlab,% 
    %basicstyle=\color{red},
    breaklines=true,%
    morekeywords={matlab2tikz},
    keywordstyle=\color{blue},%
    morekeywords=[2]{1}, keywordstyle=[2]{\color{black}},
    identifierstyle=\color{black},%
    stringstyle=\color{mylilas},
    commentstyle=\color{mygreen},%
    showstringspaces=false,%without this there will be a symbol in the places where there is a space
    %numbers=left,%
    %numberstyle={\tiny \color{black}},% size of the numbers
    numbersep=9pt, % this defines how far the numbers are from the text
    emph=[1]{for,end,break},emphstyle=[1]\color{red}, %some words to emphasise
    %emph=[2]{word1,word2}, emphstyle=[2]{style},    
}

\author{Ivan Rene Ramirez Castro\\
            \small \textit{Pontificia Universidad Javeriana}\\
            \small \today}
\title{\textbf{Analisis de algoritmos para el software TicoBingo}}
\date{\vspace{-5ex}}

\begin{document}

\twocolumn[
  \begin{@twocolumnfalse}
    \maketitle
    \begin{abstract}
      \begin{center}
El presente trabajo aborda de una manera didáctica el análisis de algoritmos para el software TicoBingo, el cual es un juego de bingo en el que se pueden jugar hasta 10 cartones al mismo tiempo. El software es desarrollado en el lenguaje de programación Java, utilizando hilos para la ejecución de los cartones. El análisis de algoritmos se realiza mediante el calculo de la complejidad temporal y espacial de los algoritmos utilizados en el software. Se realiza una comparación entre los algoritmos utilizados en el software y una implementación de los mismos tratando de minimizar la complejidad temporal y espacial. Se concluye que la implementación de los algoritmos en el software TicoBingo es óptima, ya que en promedios de tiempo son muy similares a los algoritmos optimizados creados para este análisis.
      \end{center}
    \end{abstract}
    KEYWORDS: \textit{Algoritmos, Complejidad temporal, Complejidad espacial, Bingo, Java, Hilo\\ \\}
  \end{@twocolumnfalse}
  ]
 
 \section{Introducción}
 
 En el mundo de la informática, el análisis de algoritmos es una de las herramientas más importantes para el desarrollo de software. El análisis de algoritmos permite conocer la complejidad temporal y espacial de los algoritmos utilizados en un software, lo cual permite conocer la eficiencia de los mismos. El análisis de algoritmos se realiza mediante el cálculo de la complejidad temporal y espacial de los algoritmos utilizados en el software. La complejidad temporal de un algoritmo se define como el número de operaciones básicas que se realizan para resolver un problema. La complejidad espacial de un algoritmo se define como el número de variables que se utilizan para resolver un problema. 
 
 Para nuestro caso, el software TicoBingo tiene algurítmos que se ejecutan en un tiempo muy corto, algoritmos de validaciones de victoria, creacion de cartones, entre otros.

 Nuestro objetivo es realizar un análisis de estos algoritmos y compararlos con una implementación de los mismos tratando de minimizar la complejidad temporal y espacial.

\subsection{TicoBingo}

El juego TicoBingo es un juego de bingo en el que se pueden jugar hasta 10 cartones al mismo tiempo. 
El software es desarrollado en el lenguaje de programación Java, utilizando hilos para la ejecución de los cartones.
El juego se inicia con la creación de los cartones, los cuales son creados de manera aleatoria teniendo en cuenta que no se repitan los números en un mismo cartón.
Cada cartón es un hilo separado que llenará su propio cartón y luego se duerme, pero cuando se genera una bolita desde el programa principal (tómbola), se despiertan todos los hilos al mismo tiempo para que busquen en su cartón si ese número está presente y lo marcará (Colorea) en el cartón de la vista. Luego de marcar la casilla con el número de la tómbola que acaba de salir, cada hilo debe revisar si ha ganado la partida, y si gana, el juego termina y el jugador de ese cartón gana, pero si no gana ningún cartón los hilos se duermen para esperar que salga otra bolita de la tómbola.


  \begin{figure}[h]
 	\centering
 	\includegraphics[width=0.5\textwidth]{ticobingointro.png}
 	\caption{Interfaz del juego TicoBingo}
 	\label{arreglo_pv}
 \end{figure}

% Seccion para explicar el tablero de bingo
\subsection{Tablero de bingo}

El tablero de bingo es una matriz de 5x5, en la cual se colocan los números aleatorios del 1 al 15, en la primera columna, los números del 16 al 30 en la segunda columna, los números del 31 al 45 en la tercera columna, los números del 46 al 60 en la cuarta columna y los números del 61 al 75 en la quinta columna. En el centro de la matriz se coloca el número 0, ya que esta casilla no se utiliza en el juego. Un numero solo puede aparecer una unica vez en la matriz.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.5\textwidth]{tablerobingointro.png}
	\caption{Tablero de bingo}
	\label{arreglo_pv}
\end{figure}

\subsection{Victoria en el juego}

Para ganar el juego, el jugador debe marcar 5 casillas en una misma fila, columna, diagonal o conseguir las 4 esquinas.

\section{Marco teórico}

En un mundo donde la tecnología avanza a pasos agigantados, es necesario que los programas que se desarrollen sean eficientes, es decir, que se ejecuten en el menor tiempo posible. Para esto, es necesario que los algoritmos que se utilicen en los programas sean eficientes, es decir, que tengan una complejidad temporal y espacial baja.

% Un algoritmo como una caja negra
\subsection{Algoritmos}

Una buena analogía para entender un algoritmo es la de una caja negra. Una caja negra es un objeto que no se puede ver por dentro, pero se sabe que tiene una entrada y una salida. La entrada es la información que se le da a la caja negra, y la salida es la información que se obtiene de la caja negra. La caja negra realiza una serie de operaciones para obtener la salida a partir de la entrada. En el caso de los algoritmos, la entrada es el problema que se quiere resolver, y la salida es la solución del problema. El algoritmo realiza una serie de operaciones para obtener la solución a partir del problema.

Pueden existir cientos de algoritmos para resolver un mismo problema, pero no todos los algoritmos son eficientes. Un algoritmo es eficiente si tiene una complejidad temporal y espacial baja. \cite{brendomatos2020algorithm}


% Complejidad temporal
\subsection{Complejidad temporal}

La complejidad temporal es el número de operaciones que realiza un algoritmo para completar su tarea (considerando que cada operación dura el mismo tiempo). El algoritmo que realiza la tarea en el menor número de operaciones se considera el más eficiente en términos de complejidad temporal. Sin embargo, la complejidad espacial y temporal se ve afectada por factores como el sistema operativo y el hardware, pero no los incluiremos en discusión. \cite{rivera2021introduccion}

Una de las notaciones más utilizadas para medir la complejidad temporal de un algoritmo es la notación Big O. La notación Big O es una notación asintótica que nos permite medir la complejidad temporal de un algoritmo. La notación Big O nos permite medir la complejidad temporal de un algoritmo en el peor de los casos.

A partir de la notación Big O, podemos evaluar si los algoritmos que se utilizan en TicoBingo son eficientes o no.

El estado del arte de la complejidad temporal de los algoritmos se utilizan benchmarks, que son pruebas que se realizan para medir el tiempo de ejecución de un algoritmo a nivel de procesador. Sin embargo, los benchmarks no son una buena forma de medir la complejidad temporal de un algoritmo, ya que dependen de la configuración del hardware, del sistema operativo y del lenguaje de programación que se utilice.

% Complejidad espacial
\subsection{Complejidad espacial}

La complejidad espacial es la cantidad de espacio en memoria que un algoritmo emplea al ejecutarse. En otras palabras, cómo el algoritmo ocupa espacio en memoria con la cantidad de elementos de entrada que debe procesar. \cite{marcelo2021arias}

La notación Big O también se utiliza para medir la complejidad espacial de un algoritmo. La notación Big O nos permite medir la complejidad espacial de un algoritmo en el peor de los casos, pero se deben tener en cuenta los siguientes aspectos:

\begin{itemize}
\item La cantidad de memoria requerida por el código del algoritmo.
\item La cantidad de memoria requerida para almacenar los datos de entrada.
\item La cantidad de memoria requerida para los datos de salida (algoritmos como los de ordenación suelen reorganizar los datos de entrada y por ello no necesitan memoria extra para la salida).
\item La cantidad de memoria requerida en cuanto a espacio de trabajo del algoritmo para realizar los cálculos y asignaciones (tanto para variables como cualquier espacio necesario en la pila para almacenar llamadas a subrutinas, este espacio es particularmente significativo para algoritmos que utilizan técnicas recursivas).
\end{itemize} \cite{steele1977debunking}



\section{Desarrollo del programa}

El programa TicoBingo se desarrolló en el lenguaje de programación Java, para este análisis se tomaron los algoritmos que se utilizaron en el programa, se transcribieron a lenguaje de python donde se realizaron las pruebas de complejidad temporal y espacial, y la comparación con algoritmos que deben ser mas eficientes.

\subsection{Algoritmos utilizados en el programa}
% resume = {
%    name: verificarGanador,
%    type: void,
%    visibility: public,
%    parameters: [],
%    description: Valida si el tablero actual es ganador, si lo es, se agrega a la lista de ganadores del estado
% }
\begin{itemize}
\item \textbf{verificarGanador}: Valida si el tablero actual es ganador, si lo es, se agrega a la lista de ganadores del estado.
 % resume = {
% name: generarTableroAleatorio,
% type: void,
% visibility: private,
% parameters: [],
% description: Genera un tablero aleatorio
% }
\item \textbf{generarTableroAleatorio}: Genera un tablero aleatorio.
% resume = {
% name: estaRepetido,
% type: boolean,
% visibility: private,
% parameters: [numero],
% description: Verifica si un numero esta repetido en el tablero
% }
\item \textbf{estaRepetido}: Verifica si un numero esta repetido en el tablero.
% resume = {
% name: generarNumeroAleatorio,
% type: int,
% visibility: private,
% parameters: [minimo, maximo],
% description: Genera un numero aleatorio entre minimo y maximo
% }
\item \textbf{generarNumeroAleatorio}: Genera un numero aleatorio entre minimo y maximo.

\end{itemize}


\subsection{Análisis de complejidad temporal}

\subsubsection{verificarGanador}

El algoritmo verificarGanador se encarga de verificar si el tablero actual es ganador, si lo es, se agrega a la lista de ganadores del estado. El algoritmo verificarGanador se muestra a continuación:

\begin{lstlisting}

public void verificarGanador() {
	boolean ganador = true;
	for (int i = 0; i < 5; i++) {
		for (int j = 0; j < 5; j++) {
			if (tablero[i][j] == 0) {
				ganador = false;
			}
		}
	}
	if (ganador) {
		ganadores.add(tablero);
	}
}


\end{lstlisting}
\newpage
\section{Conclusiones}

El algoritmo implementado para el MPPT en el convertidor boost presenta una respuesta satisfactoria ya que la eficiencia del modelo es aproximadamente es del 96 $\%$, lo que fundamenta la importancia del uso de algoritmos para aprovechar la máxima potencia entregada por el sistema fotovoltaico y que pueda mitigar el problema de la no linealidad del modelo matemático que rige este sistema.
Se recomienda proceder con el desarrollo experimental que pueda corroborar dichos resultados. Así mismo simular este sistema con otros algoritmos MPPT para verificar el más apropiado. Finalmente se recomienda variar el ciclo útil en lazo abierto para verificar que la potencia entregada sea la máxima requerida.
\newpage

\bibliographystyle{ieeetr}
\bibliography{mybib}

\end{document}